This script creates all figures and tables except for the singlepool Tagbias figures. It continues after 2_SoupII_fastp_to_Begum_Metabarcoding_pipeline.sh has moved the OTU tables and MTB_Blast results to analysis/ folder. 

```{r setup, message=FALSE, eval=FALSE}
# copy the following into each script   
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	include = FALSE
)

# script-specific libraries
library(vegan)
library(car)
# remotes::install_github("grunwaldlab/metacoder")
library(metacoder)
library(xlsx)
library(ggeffects)

# my general-use packages
library(here)
library(tidyverse) 
library(readxl)
library(cowplot)
library(lubridate)
library(patchwork)
library(arsenal) # for summary(comparedf())
library(sjmisc) # for rotate_df()
library(broom)
library(lme4)
library(MuMIn)
library(ggeasy)
library(RColorBrewer)
library(gt)
library(envDocument)
library(conflicted)
  conflict_prefer("mutate", "dplyr", quiet = TRUE)
  conflict_prefer("select", "dplyr", quiet = TRUE)
  conflict_prefer("summarise", "dplyr", quiet = TRUE)
  conflict_prefer("filter", "dplyr", quiet = TRUE)
  conflict_prefer("first", "dplyr", quiet = TRUE)
  conflict_prefer("here", "here", quiet = TRUE)
  conflict_prefer("separate", "tidyr", quiet = TRUE)
  conflict_prefer("unite", "tidyr", quiet = TRUE)
  conflict_prefer("intersect", "dplyr", quiet = TRUE)
  conflict_prefer("year", "lubridate", quiet = TRUE)
  conflict_prefer("setdiff", "dplyr", quiet = TRUE) 

# Provide real numbers, not scientific notation.
options(scipen = 999)
```

########################################################################
Import tables and join with metadata
########################################################################

Import OTU tables. These tables include only Arthropoda-assigned OTUs.

Load begumfilter value and run pipeline until code chunk 'hits dropouts and dropins for Begumfilter with 1 or 2 PCRs'
```{r begumfilter selection, eval=FALSE}
begumfilter <- "Filter_min2PCRs_min4copies" # Begumfilter stringency level under which most figures and analyses were run (except Table S_1, which presents all stringency levels)
```

```{r import OTU tables for a given Begumfilter}
otutables <- "table_BioSoupII_97_Arthropoda_\\w.txt"

otu_files <- list.files(Sys.glob(file.path("..", "analysis", begumfilter)), 
                        pattern = otutables, full.names = TRUE)
    # list.files is used to look for files matching "table_BioSoupII_97_Arthropoda_\\w.txt"
    # full.names = TRUE returns the pathnames
    # \\ is used to escape \ and . (because otherwise they are read with grep as "ignore" and "any character". R needs a second \)
head(otu_files); cat("    ", length(otu_files), "total files")

# function to read_tsv the files
readotutables <- function(x) {
    df <- read_tsv(x, na = "NA") 
    df
}
otu <- map(otu_files, readotutables)

# name dfs in spl list
folderpoolvec <- sub("table_BioSoupII_97_Arthropoda_(\\w).txt", 
                     "\\1", basename(otu_files), perl=TRUE)

names(otu) <- folderpoolvec

# individual otu tables can be referred to as otu$folder: otu$A
```

Rotate OTU tables and and set 1-read cells to 0
```{r filter OTU tables for min OTU size and set 1-read cells to 0}
threshold_otu_size <- 1 # option to set minimum OTU size. To not filter by OTU size, set to value 1
set_one_read_cells_to <- 0 # option to set cells with just 1 read to 0. To not filter by cell size, set to value 1

minOTUsizefilter <- function(df){
    df <- df %>% select(-starts_with("PC"), -starts_with("xb")) # tidyverse
    df <- rotate_df(df, cn = TRUE) # sjmisc
    df <- df[, colSums(df) >= threshold_otu_size] # base R
    df[df == 1] <- set_one_read_cells_to # base R
    df
}

OTUminsize <- map(otu, minOTUsizefilter) 
```

Manually check that all samples (rows) still have sufficient numbers of reads in them.  This isn't a risk with this dataset, but some datasets have samples with few, low-read-number OTUs. Removing small OTUs will sometimes produce samples (rows) that have almost no data, because that sample failed during PCR or DNA extraction. 
```{r view rowsums, eval=FALSE}
tablerowsums <- map_dfr(OTUminsize, rowSums) # output has samples in columns, PCRs in rows
View(tablerowsums)
```


########################################################################
Hits, False-negatives, and False-positives, Tables 3 and S_1
########################################################################

Combine echo OTUs and count the number of drop-ins and drop-outs.  

Echoes are split OTUs. (i.e. 1 high pident and N moderately high pident OTUs)
Drop-ins are OTUs that do not match any of the MTB refs (i.e. a pident <97% to all MTBs)
Drop-outs are MTB seqs that were not matched by any OTU at >= 97% similarity

Import BLAST/vsearch tables. I am using the vsearch tables; the BLAST results are similar 
```{r import blast vsearch tables}
# otutables <- "table_BioSoupII_\\w_Arthropoda.blastnMTB.txt"
otutables <- "table_BioSoupII_\\w_Arthropoda.vsearchMTB.txt"
begumfilter # confirm correct stringency level

otu_files <- list.files(Sys.glob(file.path("..", "analysis", begumfilter)), 
                        pattern = otutables, full.names = TRUE)
    # list.files is used to look for files matching "table_BioSoupII_97_Arthropoda_\\w.txt"
    # full.names = TRUE returns the pathnames
    # \\ is used to escape \ and . (because otherwise they are read with grep as "ignore" and "any character". R needs a second \)
head(otu_files); cat("    ", length(otu_files), "total files")

mtbcolnames <- c("qseqid", "sseqid", "pident", "length", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore")

pident_threshold <- 94 # initial filtering, to be filtered more stringently later
length_threshold <- 250 # initial filtering, to be filtered more stringently later

# function to read_tsv the files
readotutables <- function(x) {
    df <- read_tsv(x, na = "NA", col_names = mtbcolnames) %>% 
        filter(pident >= pident_threshold & length > length_threshold) %>% 
        separate(col = qseqid, c("qseqid", "size"), sep = ";")
    df
}


blastmtb <- map(otu_files, readotutables) # note that this could contain either the blastn or vsearch results. I'm using the vsearch results

# name dfs in spl list
# foldervec <- sub("table_BioSoupII_(\\w)_Arthropoda.blastnMTB.txt", "\\1", basename(otu_files), perl=TRUE)
foldervec <- sub("table_BioSoupII_(\\w)_Arthropoda.vsearchMTB.txt", "\\1",
                 basename(otu_files), perl=TRUE)
names(blastmtb) <- foldervec
# individual otu tables can be referred to as blastout$folder: blastout$A
```

Import the input amounts per soup per ref species, qPCR for COI and Biotek for genomic DNA
```{r import MTB DNA input amt table}
# read in MTB_REF file (updated on 20171129 to include the input DNA amounts and morphological ID to order level)
MTB_AllInputRefSeqs <- file.path("..", "data", "MTB",
                                 "S2_MTB_AllInputRefSeqs_20200401.xlsx")

MTB_excel <- read_excel(path = MTB_AllInputRefSeqs, sheet = "MTB_RefSeqs_DNAconc", col_types = c("text","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric","numeric", "text","text"), na = "NA")
```

Join the OTU tables with the BLAST or vsearch tables, and then join the MTB_excel table to add DNA concentrations and morphological IDs. Final table is *OTUBLASTqpcr*
```{r join otu blast or vsearch mtb excel tables}
joinfxn1 <- function(blasttable, otutable){
    otutable_t <- rotate_df(otutable, rn = "OTU_ID")
    df <- left_join(otutable_t, blasttable, by = c("OTU_ID" = "qseqid"))
}
joinfxn2 <- function(OTUBLASTtable, MTB_excel){
    df <- left_join(OTUBLASTtable, MTB_excel, by = c("sseqid" = "MTBseq"))
}

OTUBLAST <- map2(blastmtb, OTUminsize, joinfxn1)

MTB_excel_list <- list(MTB_excel, MTB_excel, MTB_excel, MTB_excel, MTB_excel, MTB_excel, MTB_excel, MTB_excel)

OTUBLASTqpcr <- map2(OTUBLAST, MTB_excel_list, joinfxn2)
```

Now I have a complete table. Next step is to calculate hits (recovered input species), dropouts, and drop-ins after filtering for pident_threshold2, filtering out PC OTUs, and summing together echo OTUs when counting up hits. 

Echo OTUs are MTB seqs that are hit by multiple OTUs, due to incomplete clustering. We are not testing OTU clustering methods, so while we don't like this, we consider a hit by 1 or more OTUs to be a success with regards to recovering the information. Echo OTUs are not very common, and there is usually one large OTU with high similarity to the MTBseq and occasionally one or more small echo OTUs that have fewer reads at >=97% similarity.

Filter_min1PCRs
Filter_min2PCRs
```{r hits dropouts and dropins for Begumfilter with 1 or 2 PCRs}
pident_threshold2 <- 97 # min % similarity to be considered a match to an MTBseq

# number of hit OTUs per soup (OTUs >=97% similar to an MTBseq), combine echo OTUs
# sseqids are the 248 input and 4 positive-control sequences
MTB_hits <- function(OTUBLASTqpcr) {
    OTUBLASTqpcr %>% 
    filter(!is.na(sseqid)) %>%  # remove drop-ins
    filter(pident >= pident_threshold2) %>% # remove drop-ins
    filter(!str_starts(sseqid, "P")) %>% # remove hits to positive-ctrl species
    select(hlllleg, hlllbody, Hhmlleg, Hhmlbody, hhhlleg, hhhlbody, mmmmleg, mmmmbody, sseqid) %>% 
    group_by(sseqid) %>% # group by MTBseq
    summarise(across(.cols = c(hlllleg, hlllbody, Hhmlleg, Hhmlbody, hhhlleg, hhhlbody, mmmmleg, mmmmbody), ~sum(.x, na.rm = TRUE))) %>% # sum reads by sseqid to group echo OTUs
    mutate(across(where(is.numeric), ~1 * (.x > 0))) %>% # transform sums > 1 to 1 to count multiple hits to each sseqid only once
    ungroup() %>% 
    summarise(across(.cols = c(hlllleg, hlllbody, Hhmlleg, Hhmlbody, hhhlleg, hhhlbody, mmmmleg, mmmmbody), ~sum(.x, na.rm = TRUE))) # sum hits over all sseqid
}

# number of drop-in OTUs, defined as no-hit to MTBseq or pident<97%
OTU_dropins <- function(OTUBLASTqpcr) {
    OTUBLASTqpcr %>% 
    filter(is.na(sseqid) | pident < pident_threshold2) %>% # keep drop-ins
    mutate(across(where(is.numeric), ~1 * (.x > 0))) %>% # convert numbers >1 to 1
    summarise(across(.cols = c(hlllleg, hlllbody, Hhmlleg, Hhmlbody, hhhlleg, hhhlbody, mmmmleg, mmmmbody), ~sum(.x, na.rm = TRUE))) # sum reads by sseqid to remove echo OTUs
}

OTUBLAST_hits <- map_dfr(OTUBLASTqpcr, MTB_hits, .id = "PCR")
OTUBLAST_dropins <- map_dfr(OTUBLASTqpcr, OTU_dropins, .id = "PCR")

# calculate numbers of input MTB OTUs recovered by metabarcoding (hits) and numbers of OTUs that are dropins, for a specific soup (for the paper: mmmmbody)
soupname <- "mmmmbody"
OTUBLAST_hits_t <- rotate_df(OTUBLAST_hits, rn = "soup", cn = TRUE) %>% 
    filter(soup == soupname)
OTUBLAST_hits_t$metric <- "hits"

OTUBLAST_dropins_t <- rotate_df(OTUBLAST_dropins, rn = "soup", cn = TRUE) %>% 
    filter(soup == soupname)
OTUBLAST_dropins_t$metric <- "dropins"


# calculate % of input MTB OTUs that are hits
maxMTB <- 248 # max number of input OTUs

OTUBLAST_hits_pct <- OTUBLAST_hits_t %>% 
    mutate_at(vars(A:H), list(~ ./maxMTB)) %>%
    mutate_at(vars(A:H), list(~ round(., digits = 3)))
OTUBLAST_hits_pct$metric <- "hit_pct"

# calculate proportion dropins as dropins/maxMTB to generate a measure of dropins relative to the number of true input sequences. 
OTUBLAST_dropins_pct <- OTUBLAST_dropins_t %>% 
    mutate_at(vars(A:H), list(~ ./maxMTB)) %>%
    mutate_at(vars(A:H), list(~ round(., digits = 3)))
OTUBLAST_dropins_pct$metric <- "dropin_pct"

# calculate number of dropouts 
OTUBLAST_dropouts <- OTUBLAST_hits_t %>% 
    mutate_at(vars(A:H), list(~maxMTB - .))
OTUBLAST_dropouts$metric <- "dropouts"

# calculate % dropouts as a proportion of true input sequences
OTUBLAST_dropouts_pct <- OTUBLAST_dropouts %>% 
    mutate_at(vars(A:H), list(~ ./maxMTB)) %>%
    mutate_at(vars(A:H), list(~ round(., digits = 3)))
OTUBLAST_dropouts_pct$metric <- "dropouts_pct"

# create sub-table for Table DROPS
assign(paste("OTUBLAST_all", pident_threshold2, begumfilter, sep = "_"), bind_rows(OTUBLAST_hits_t, OTUBLAST_dropouts, OTUBLAST_dropouts_pct, OTUBLAST_dropins_t, OTUBLAST_dropins_pct))
# assign() command builds begumfilter into object names
# e.g. OTUBLAST_all_97_Filter_min1PCRs_min1copies
```

In order to run all 12 stringency values for Table S_1, I have provided them here. Select one level and then run the code above this chunk. For each one, a subtable will be created with object name format: OTUBLAST_all_97_Filter_min1PCRs_min1copies
```{r begumfilter selection for Filter_min1_2PCRs, eval=FALSE}
begumfilter <- "Filter_min1PCRs_min1copies"
begumfilter <- "Filter_min1PCRs_min2copies"
begumfilter <- "Filter_min1PCRs_min3copies"
begumfilter <- "Filter_min1PCRs_min4copies"

begumfilter <- "Filter_min2PCRs_min1copies"
begumfilter <- "Filter_min2PCRs_min2copies"
begumfilter <- "Filter_min2PCRs_min3copies"
begumfilter <- "Filter_min2PCRs_min4copies" # Begumfilter stringency level under which most figures and analyses were run (except Table S_1, which presents all stringency levels)
```

The Filter_min3PCRs tables have a problem in that H1 is missing. So the hits and dropouts code is modified. Select each Filter level, run the code above EXCEPT for 'hits dropouts and dropins for Begumfilter with 1 or 2 PCRs' and then run 'hits dropouts and dropins for Begumfilter with 3 PCRs'
```{r begumfilter selection for Filter_min3PCRs, eval=FALSE}
begumfilter <- "Filter_min3PCRs_min1copies"
begumfilter <- "Filter_min3PCRs_min2copies"
begumfilter <- "Filter_min3PCRs_min3copies"
begumfilter <- "Filter_min3PCRs_min4copies"
```

Filter_min3PCRs, Modified code because PCR H1 lacks hhhlbody
```{r hits dropouts and dropins for Begumfilter with 3 PCRs}
pident_threshold2 <- 97 # min % similarity to be considered a match to an MTBseq

# number of hit OTUs per soup (OTUs matching an MTBseq), combining echo OTUs
MTB_hits <- function(OTUBLASTqpcr) {
    OTUBLASTqpcr %>% 
    filter(!is.na(sseqid)) %>%  # remove drop-ins
    filter(pident >= pident_threshold2) %>% # remove drop-ins
    filter(!str_starts(sseqid, "P")) %>% # remove hits to positive ctrl
    select(hlllleg, hlllbody, Hhmlleg, Hhmlbody, hhhlleg, mmmmleg, mmmmbody,sseqid) %>% 
    group_by(sseqid) %>% # group by MTBseq
    summarise_at(vars(hlllleg, hlllbody, Hhmlleg, Hhmlbody, hhhlleg, mmmmleg, mmmmbody), sum, na.rm = TRUE) %>% # sum reads per sseqid
    mutate_if(is.numeric, ~1 * (. > 0)) %>% # convert read sums > 1 to 1
    ungroup() %>% 
    summarise_at(vars(hlllleg, hlllbody, Hhmlleg, Hhmlbody, hhhlleg, mmmmleg, mmmmbody), sum, na.rm = TRUE) # sum hits over all sseqid
}

# number of drop-in OTUs, defined as no-hit to MTBseq or pident<97% (~50% each type)
OTU_dropins <- function(OTUBLASTqpcr) {
    OTUBLASTqpcr %>% 
    filter(is.na(sseqid) | pident < pident_threshold2) %>% # keep drop-ins
    mutate_if(is.numeric, ~1 * (. > 0)) %>% # convert numbers > 1 to 1
    summarise_at(vars(hlllleg, hlllbody, Hhmlleg, Hhmlbody, hhhlleg, mmmmleg, mmmmbody), sum, na.rm = TRUE)
}

OTUBLAST_hits <- map_dfr(OTUBLASTqpcr, MTB_hits, .id = "PCR")
OTUBLAST_dropins <- map_dfr(OTUBLASTqpcr, OTU_dropins, .id = "PCR")

maxMTB <- 248 # max number of input OTUs

# calculate numbers of input MTB OTUs recovered by metabarcoding (hits) and numbers of OTUs that are dropins, for a specific soup (for the paper: mmmmbody)
soupname <- "mmmmbody"
OTUBLAST_hits_t <- rotate_df(OTUBLAST_hits, rn = "soup", cn = TRUE) %>% 
    filter(soup == soupname)
OTUBLAST_hits_t$metric <- "hits"

OTUBLAST_dropins_t <- rotate_df(OTUBLAST_dropins, rn = "soup", cn = TRUE) %>% 
    filter(soup == soupname)
OTUBLAST_dropins_t$metric <- "dropins"

# calculate % of input MTB OTUs recovered by metabarcoding and round to 2 digits
OTUBLAST_hits_pct <- OTUBLAST_hits_t %>% 
    mutate_at(vars(A:H), list(~ ./maxMTB)) %>%
    mutate_at(vars(A:H), list(~ round(., digits = 3)))
OTUBLAST_hits_pct$metric <- "hit_pct"

# calculate proportion dropins as dropins/maxMTB to generate a measure of dropins relative to the number of true input sequences. 
OTUBLAST_dropins_pct <- OTUBLAST_dropins_t %>% 
    mutate_at(vars(A:H), list(~ ./maxMTB)) %>%
    mutate_at(vars(A:H), list(~ round(., digits = 3)))
OTUBLAST_dropins_pct$metric <- "dropin_pct"

# calculate number of dropouts
OTUBLAST_dropouts <- OTUBLAST_hits_t %>% 
    mutate_at(vars(A:H), list(~maxMTB - .))
OTUBLAST_dropouts$metric <- "dropouts"

# calculate % dropouts as a proportion of true input sequences
OTUBLAST_dropouts_pct <- OTUBLAST_dropouts %>% 
    mutate_at(vars(A:H), list(~ ./maxMTB)) %>%
    mutate_at(vars(A:H), list(~ round(., digits = 3)))
OTUBLAST_dropouts_pct$metric <- "dropouts_pct"

# create sub-table for Table DROPS
assign(paste("OTUBLAST_all", pident_threshold2, begumfilter, sep = "_"), bind_rows(OTUBLAST_hits_t, OTUBLAST_dropouts, OTUBLAST_dropouts_pct, OTUBLAST_dropins_t, OTUBLAST_dropins_pct))
# assign() command builds begumfilter into object names
# e.g. OTUBLAST_all_97_Filter_min1PCRs_min1copies
```

Rerun the above starting from code chunk `import OTU tables` for all three begumfilter values. When finished, add begumfilter metadata, combine subtables, and write Table DROPs to file:
```{r Table 3 and S_1}
OTUBLAST_all_97_Filter_min1PCRs_min1copies$begumfilter <- "min1PCRs_min1copies"
OTUBLAST_all_97_Filter_min1PCRs_min2copies$begumfilter <- "min1PCRs_min2copies"
OTUBLAST_all_97_Filter_min1PCRs_min3copies$begumfilter <- "min1PCRs_min3copies"
OTUBLAST_all_97_Filter_min1PCRs_min4copies$begumfilter <- "min1PCRs_min4copies"
OTUBLAST_all_97_Filter_min2PCRs_min1copies$begumfilter <- "min2PCRs_min1copies"
OTUBLAST_all_97_Filter_min2PCRs_min2copies$begumfilter <- "min2PCRs_min2copies"
OTUBLAST_all_97_Filter_min2PCRs_min3copies$begumfilter <- "min2PCRs_min3copies"
OTUBLAST_all_97_Filter_min2PCRs_min4copies$begumfilter <- "min2PCRs_min4copies"
OTUBLAST_all_97_Filter_min3PCRs_min1copies$begumfilter <- "min3PCRs_min1copies"
OTUBLAST_all_97_Filter_min3PCRs_min2copies$begumfilter <- "min3PCRs_min2copies"
OTUBLAST_all_97_Filter_min3PCRs_min3copies$begumfilter <- "min3PCRs_min3copies"
OTUBLAST_all_97_Filter_min3PCRs_min4copies$begumfilter <- "min3PCRs_min4copies"

Table_DROPS_97 <- bind_rows(OTUBLAST_all_97_Filter_min1PCRs_min1copies,
                            OTUBLAST_all_97_Filter_min1PCRs_min2copies,
                            OTUBLAST_all_97_Filter_min1PCRs_min3copies,
                            OTUBLAST_all_97_Filter_min1PCRs_min4copies,
                            OTUBLAST_all_97_Filter_min2PCRs_min1copies,
                            OTUBLAST_all_97_Filter_min2PCRs_min2copies,
                            OTUBLAST_all_97_Filter_min2PCRs_min3copies,
                            OTUBLAST_all_97_Filter_min2PCRs_min4copies,
                            OTUBLAST_all_97_Filter_min3PCRs_min1copies,
                            OTUBLAST_all_97_Filter_min3PCRs_min2copies,
                            OTUBLAST_all_97_Filter_min3PCRs_min3copies,
                            OTUBLAST_all_97_Filter_min3PCRs_min4copies
                            ) %>% 
    select(soup, begumfilter, metric, everything())

# save Table S_1, from which Table 3 was created
write.xlsx(Table_DROPS_97, file.path("..", "results", "Table_S_1.xlsx"), sheetName = "Table_S_1", row.names = FALSE)
```


########################################################################
Community analysis, Figure 2
########################################################################

Plot NMDS of every OTU table. Using Begumfilter stringency level "Filter_min2PCRs_min4copies"
```{r ordinations and plot ordinations, eval=FALSE}
(colorvec <- c("#EF8A62", "#67A9CF"))  # from:  brewer.pal(3,"RdBu")

extract_env <- function(x){
    ## extract env variables
    env <- x %>%
        rownames_to_column() %>% 
        select(sample = rowname) %>% 
        mutate(
            bodypart = case_when(
                grepl("body", sample) == TRUE ~ "body",
                grepl("leg", sample) == TRUE ~ "leg"
            )
        ) %>%
        mutate(
            bodypartcolor = if_else(bodypart == "body", 1, 2)
        ) %>% 
        mutate(
            evenness = str_remove(sample, c("body|leg"))
        )
    env$sprichness <- specnumber(x, MARGIN = 1)
    env
}
ordination <- function(x){
    df <- metaMDS(x, distance = "bray", trymax = 40, binary=FALSE)
    df
}
# ordinationplot(ordinations, plottitle, envs)
ordinationplot <- function(x, y, z){
  xlim <- c(-1, 1) 
  ylim <- c(-0.75, 0.75) 
  plot(x, ylab="NMDS2", xlab="NMDS1", xlim=xlim, ylim=ylim, type="n", main=y) 
   
  points(x, display = "sites", pch=16, cex=(z$sprichness/40), col=colorvec)
  
  with(z, legend("top", legend = unique(bodypart), bty = "n", col=colorvec, pt.cex=2, pch=16, y.intersp = 1))
  
  cexnum <- 0.5
  
  with(z, ordispider(x, evenness, cex=cexnum, col=c("black"), label=TRUE, show.groups=(c("hlll"))))
  with(z, ordispider(x, evenness, cex=cexnum, col=c("black"), label=TRUE, show.groups=(c("Hhml"))))
  with(z, ordispider(x, evenness, cex=cexnum, col=c("black"), label=TRUE, show.groups=(c("hhhl"))))
  with(z, ordispider(x, evenness, cex=cexnum, col=c("black"), label=TRUE, show.groups=(c("mmmm"))))
}
stressplotfxn <- function(x){
    stressplot(x)
}

OTUminsize_all <- OTUminsize

# plot stressplots
par(mfrow=c(3,3))
ordinations <- map(OTUminsize_all, ordination)
map(ordinations, stressplotfxn)
par(mfrow=c(1,1))

# ordinations and ordination plots 
# extract env data
envs <- map(OTUminsize, extract_env)
# run metaMDS
ordinations <- map(OTUminsize, ordination)
# extract names of the jmds elements
plottitle <- names(ordinations)
# plot ordinations, with jmds names as plot titles
par(mfrow=c(2,2))
pmap(list(ordinations, plottitle, envs), ordinationplot) # creates two pages of plots
par(mfrow=c(1,1))
```

plot an ordination from just one experiment (PCR A). This figure is used for "Figure 2". Using Begumfilter stringency level "Filter_min2PCRs_min4copies"
```{r ordination and plot ordination from one pcr Figure NMDS, eval=FALSE}
OTUminsize_one <- OTUminsize["A"]

# ordinations and ordination plots 
# extract env data
par(mfrow=c(1,1))
envs <- map(OTUminsize_one, extract_env)
# run metaMDS
ordination_one <- map(OTUminsize_one, ordination)
# extract names of the jmds elements
plottitle <- names(ordination_one)
# plot ordination, with jmds names as plot titles
pmap(list(ordination_one, plottitle, envs), ordinationplot)
```
  
########################################################################
Evenness analysis, Figure S_1
########################################################################
Using Begumfilter stringency level "Filter_min2PCRs_min4copies"
```{r Figure S_1}
OTUBLAST_hits_t_all_long <- rotate_df(OTUBLAST_hits, rn = "soup", cn = TRUE) %>% 
    pivot_longer(A:H, names_to = "PCR", values_to = "OTU_hits") %>% 
    mutate(
        shannon = case_when(
            soup == "hlllbody" ~ 4.08,
            soup == "Hhmlbody" ~ 4.56,
            soup == "hhhlbody" ~ 5.17,
            soup == "mmmmbody" ~ 5.39,
            soup == "hlllleg" ~ 4.13,
            soup == "Hhmlleg" ~ 4.21,
            soup == "hhhlleg" ~ 5.04,
            soup == "mmmmleg" ~ 5.32
        ),
        bodypart = case_when(
            str_detect(soup, "leg") == TRUE ~ "leg",
            str_detect(soup, "body") == TRUE ~ "body"
        )
    ) 

# regression random-effects models, body and leg fit separately
bodydf <- OTUBLAST_hits_t_all_long %>% filter(bodypart == "body")
legdf <- OTUBLAST_hits_t_all_long %>% filter(bodypart == "leg")
 
# bodydf
mod1 <- lmer(OTU_hits ~ shannon + (1 | PCR), data = bodydf, REML = FALSE)
mod2 <- lmer(OTU_hits ~ 1 + (1 | PCR), data = bodydf, REML = FALSE)
anova(mod1, mod2)
# P < 0.001
mod1.body.final <- lmer(OTU_hits ~ shannon + (1 | PCR), data = bodydf, REML = TRUE)
r.squaredGLMM(mod1.body.final) # MuMin package
# R2m: 0.798

# legdf
mod1 <- lmer(OTU_hits ~ shannon + (1 | PCR), data = legdf, REML = FALSE)
mod2 <- lmer(OTU_hits ~ 1 + (1 | PCR), data = legdf, REML = FALSE)
anova(mod1, mod2)
AIC(mod1, mod2)
mod1.leg.final <- lmer(OTU_hits ~ shannon + (1 | PCR), data = legdf, REML = TRUE)
summary(mod1.leg.final) # PCR random effects variance = 0.0 (singularity)
mod3 <- lm(OTU_hits ~ shannon, data = legdf)
AIC(mod1, mod3)
#      df      AIC
# mod1  4 315.9662
# mod3  3 313.9662
summary(mod3)
#             Estimate Std. Error t value Pr(>|t|)    
# (Intercept)  -100.16      49.58  -2.020 0.052370 .  
# shannon        45.57      10.54   4.323 0.000156 ***

body <- 
    ggplot(bodydf, aes(x = shannon, y = OTU_hits, group = PCR, colour = PCR)) +
    geom_point() +
    ylim(50, 250) +
    geom_line(data = cbind(bodydf, pred = predict(mod1.body.final)), 
              aes(y = pred), size = 1) +
    labs(x = "Evenness (Shannon diversity)", 
         y = "Number of OTUs matched to a Reference") +
    theme_cowplot() +
    facet_wrap(~bodypart) +
    scale_colour_viridis_d(option = "cividis") +
    theme(legend.position='none') +
    annotate("text", x = 4.2, y = 55, label = "hlll") +
    annotate("text", x = 4.65, y = 185, label = "Hhml") +
    annotate("text", x = 5.2, y = 130, label = "hhhl") +
    annotate("text", x = 5.3, y = 180, label = "mmmm") +
    annotate("text", x = 4.6, y = 250, label = "paste(\"p<0.0001, \", italic(marginal_R) ^ 2, \" = 79.9\")", parse = TRUE)

leg <- 
    ggplot(legdf, aes(x = shannon, y = OTU_hits, group = PCR, colour = PCR)) +
    geom_point() +
    ylim(50, 250) +
    geom_line(data = cbind(legdf, pred = predict(mod3)), 
              aes(y = pred), size = 1) +
    labs(x = "Evenness (Shannon diversity)", 
         y = "Number of OTUs matched to a Reference") +
    theme_cowplot() +
    facet_wrap(~bodypart) +
    scale_colour_viridis_d(option = "cividis", direction = -1) +
    theme(axis.title.y = element_blank()) +
    annotate("text", x = 4.22, y = 70, label = "hlll") +
    annotate("text", x = 4.3, y = 120, label = "Hhml") +
    annotate("text", x = 5.1, y = 190, label = "hhhl") +
    annotate("text", x = 5.25, y = 100, label = "mmmm") +
    annotate("text", x = 4.6, y = 250, 
             label = "paste(\"p<0.0001, \", italic(R) ^ 2, \" = 38.3\")", 
             parse = TRUE)   

body + leg

# plots using geom_smooth(method = "lm")
# body <- OTUBLAST_hits_t_all_long %>% 
#     filter(bodypart == "body") %>% 
#     ggplot(. , aes(x = shannon, y = OTU_hits, group = PCR, colour = PCR)) +
#     geom_point() +
#     ylim(50, 250) +
#     geom_smooth(method = "lm", se = FALSE) +
#     # geom_line(data = mod1bodypred, aes(x = x, y = predicted)) +
#     # geom_ribbon(data = mod1bodypred, aes(x = x, ymin = conf.low, ymax = conf.high),
#     #             alpha = 0.15, fill = "green") +
#     labs(x = "Evenness (Shannon diversity)", 
#          y = "Number of OTUs matched to a Reference") +
#     theme_cowplot() +
#     # facet_wrap(~bodypart) +
#     scale_colour_viridis_d(option = "cividis") +
#     theme(legend.position='none') +
#     annotate("text", x = 4.2, y = 55, label = "hlll") +
#     annotate("text", x = 4.65, y = 185, label = "Hhml") +
#     annotate("text", x = 5.2, y = 130, label = "hhhl") +
#     annotate("text", x = 5.3, y = 180, label = "mmmm") +
#     annotate("text", x = 4.6, y = 250, label = "paste(\"p<0.001, \", italic(marginal_R) ^ 2, \" = 79.9\")", parse = TRUE)
# 
# leg <- OTUBLAST_hits_t_all_long %>% 
#     filter(bodypart == "leg") %>% 
#     ggplot(. , aes(x = shannon, y = OTU_hits, group = PCR, colour = PCR)) +
#     geom_point() +
#     ylim(50, 250) +
#     geom_smooth(method = "lm", se = FALSE) +
#     # geom_line(data = mod1legpred, aes(x = x, y = predicted)) +
#     # geom_ribbon(data = mod1legpred, aes(x = x, ymin = conf.low, ymax = conf.high),
#     #             alpha = 0.15, fill = "green") +
#     labs(x = "Evenness (Shannon diversity)", 
#          y = "Number of OTUs matched to a Reference") +
#     theme_cowplot() +
#     # facet_wrap(~bodypart) +
#     scale_colour_viridis_d(option = "cividis") +
#     theme(axis.title.y = element_blank()) +
#     annotate("text", x = 4.22, y = 70, label = "hlll") +
#     annotate("text", x = 4.3, y = 120, label = "Hhml") +
#     annotate("text", x = 5.1, y = 190, label = "hhhl") +
#     annotate("text", x = 5.25, y = 100, label = "mmmm") +
#     annotate("text", x = 4.6, y = 250, label = "paste(\"p<0.001, \", italic(marginal_R) ^ 2, \" = 37.6\")", parse = TRUE)   
# 
# body + leg
```

########################################################################
Evenness analysis, Figure S_2
########################################################################
Using Begumfilter stringency level "Filter_min2PCRs_min4copies" and PCR A
The purpose is to see if OTU size (number of reads) predicts input DNA, measured two ways:  COI amplicon (from qPCR) and genomic DNA (from Biotek). We want to know if (1) the relationship is the same across different soups (it is not), and (2) the relationship is precise (no, a lot of noise). Note that this test is across-species quantification. 
```{r figure S_2}
MTB_quant <- function(OTUBLASTqpcr) {
    OTUBLASTqpcr %>% 
    filter(!is.na(sseqid)) %>%  # remove drop-ins
    filter(pident >= pident_threshold2) %>% # remove drop-ins
    filter(!str_starts(sseqid, "P")) %>% # remove hits to positive ctrl
    select(Hhmlbody, Hhmlleg, hhhlbody, hhhlleg, hlllbody, hlllleg, sseqid, starts_with("qPCR"), starts_with("Biotek")) %>% 
    group_by(sseqid) %>% # group by MTBseq
    summarise(
        Hhmlbody_sum = sum(Hhmlbody),
        Hhmlleg_sum = sum(Hhmlleg), 
        hhhlbody_sum = sum(hhhlbody),
        hhhlleg_sum = sum(hhhlleg), 
        hlllbody_sum = sum(hlllbody), 
        hlllleg_sum = sum(hlllleg), 
        qPCR_hlll_leg = first(qPCR_hlll_leg),
        Biotek_hlll_leg = first(Biotek_hlll_leg),
        qPCR_hhhl_leg = first(qPCR_hhhl_leg),
        Biotek_hhhl_leg = first(Biotek_hhhl_leg),
        qPCR_Hhml_leg = first(qPCR_Hhml_leg),
        Biotek_Hhml_leg = first(Biotek_Hhml_leg),
        qPCR_hlll_body = first(qPCR_hlll_body),
        Biotek_hlll_body = first(Biotek_hlll_body),
        qPCR_hhhl_body = first(qPCR_hhhl_body),
        Biotek_hhhl_body = first(Biotek_hhhl_body),
        qPCR_Hhml_body = first(qPCR_Hhml_body),
        Biotek_Hhml_body = first(Biotek_Hhml_body)
        ) # sum reads per sseqid and take first sseqid input amts. 
} # in practice, these sums have no effect because all sseqids are already unique

OTUBLASTqpcrA <- MTB_quant(OTUBLASTqpcr$A)

# correct for soup dilutions
soupdil <- read_excel(here("..", "data", "MTB", "soup_dilutions.xlsx")) %>% arrange(Soup)
# "Hhmlbody" "Hhmlleg" "hhhlbody" "hhhlleg"  "hlllbody" "hlllleg"  

# "qPCR_hlll_leg"  
# "Biotek_hlll_leg"  "qPCR_hhhl_leg"    "Biotek_hhhl_leg"  "qPCR_Hhml_leg"  
# "Biotek_Hhml_leg"  "qPCR_hlll_body"   "Biotek_hlll_body" "qPCR_hhhl_body" 
# "Biotek_hhhl_body" "qPCR_Hhml_body"   "Biotek_Hhml_body"

OTUBLASTqpcrA <- OTUBLASTqpcrA %>% 
    mutate(qPCR_hlll_leg = qPCR_hlll_leg / soupdil[soupdil$Soup == "hlllleg", ]$Dilution) %>% 
    mutate(Biotek_hlll_leg = Biotek_hlll_leg / soupdil[soupdil$Soup == "hlllleg", ]$Dilution) %>% 
    mutate(qPCR_hhhl_leg = qPCR_hhhl_leg / soupdil[soupdil$Soup == "hhhlleg", ]$Dilution) %>% 
    mutate(Biotek_hhhl_leg = Biotek_hhhl_leg / soupdil[soupdil$Soup == "hhhlleg", ]$Dilution) %>% 
    mutate(qPCR_Hhml_leg = qPCR_Hhml_leg / soupdil[soupdil$Soup == "Hhmlleg", ]$Dilution) %>% 
    mutate(Biotek_Hhml_leg = Biotek_Hhml_leg / soupdil[soupdil$Soup == "Hhmlleg", ]$Dilution) %>% 
    mutate(qPCR_hlll_body = qPCR_hlll_body / soupdil[soupdil$Soup == "hlllbody", ]$Dilution) %>% 
    mutate(Biotek_hlll_body = Biotek_hlll_body / soupdil[soupdil$Soup == "hlllbody", ]$Dilution) %>% 
    mutate(qPCR_hhhl_body = qPCR_hhhl_body / soupdil[soupdil$Soup == "hhhlbody", ]$Dilution) %>% 
    mutate(Biotek_hhhl_body = Biotek_hhhl_body / soupdil[soupdil$Soup == "hhhlbody", ]$Dilution) %>% 
    mutate(qPCR_Hhml_body = qPCR_Hhml_body / soupdil[soupdil$Soup == "Hhmlbody", ]$Dilution) %>% 
    mutate(Biotek_Hhml_body = Biotek_Hhml_body / soupdil[soupdil$Soup == "Hhmlbody", ]$Dilution)

# a different way to correct for soup dilutions, multiplying the read numbers by dilution factors
# OTUBLASTqpcrA <- OTUBLASTqpcrA %>% 
#     mutate(Hhmlbody_sum = Hhmlbody_sum * soupdil[soupdil$Soup == "Hhmlbody", ]$Dilution) %>% 
#     mutate(Hhmlleg_sum = Hhmlleg_sum * soupdil[soupdil$Soup == "Hhmlleg", ]$Dilution) %>% 
#     mutate(hhhlbody_sum = hhhlbody_sum * soupdil[soupdil$Soup == "hhhlbody", ]$Dilution) %>% 
#     mutate(hhhlleg_sum = hhhlleg_sum * soupdil[soupdil$Soup == "hhhlleg", ]$Dilution) %>% 
#     mutate(hlllbody_sum = hlllbody_sum * soupdil[soupdil$Soup == "hlllbody", ]$Dilution) %>% 
#     mutate(hlllleg_sum = hlllleg_sum * soupdil[soupdil$Soup == "hlllleg", ]$Dilution)
# 


# display.brewer.pal(7, "Set2")
(colorvec <- brewer.pal(4, "Set2"))
# "#8DD3C7" "#BEBADA" "#FB8072"

p1 <- ggplot(OTUBLASTqpcrA) +
    geom_point(aes(x=hlllbody_sum, y=qPCR_hlll_body), colour = colorvec[1]) +
    geom_smooth(aes(x=hlllbody_sum, y=qPCR_hlll_body), method="lm", se=FALSE, colour = colorvec[1]) +
    geom_point(aes(x=Hhmlbody_sum, y=qPCR_Hhml_body), colour = colorvec[2]) +
    geom_smooth(aes(x=Hhmlbody_sum, y=qPCR_Hhml_body), method="lm", se=FALSE, colour = colorvec[2]) +
    geom_point(aes(x=hhhlbody_sum, y=qPCR_hhhl_body), colour = colorvec[3]) +
    geom_smooth(aes(x=hhhlbody_sum, y=qPCR_hhhl_body), method="lm", se=FALSE, colour = colorvec[3]) +
    theme_cowplot() +
    easy_labs(x="OTU size (number of reads)", 
         y="COI amplicon concentration (ng/µl)",
         subtitle = "body") +
    easy_move_legend(to = "none") +
    annotate("text", x = 1350, y = 4.2, label = "hlll", color = colorvec[1]) +
    annotate("text", x = 3000, y = 4.5, label = "Hhml", color = colorvec[2]) +
    annotate("text", x = 1800, y = 1, label = "hhhl", color = colorvec[3]) +
    easy_x_axis_title_size(11) +
    easy_y_axis_title_size(11)


p2 <- ggplot(OTUBLASTqpcrA) +
    geom_point(aes(x=hlllbody_sum, y=Biotek_hlll_body), colour = colorvec[1]) +
    geom_smooth(aes(x=hlllbody_sum, y=Biotek_hlll_body), method="lm", se=FALSE, colour = colorvec[1]) +
    geom_point(aes(x=Hhmlbody_sum, y=Biotek_Hhml_body), colour = colorvec[2]) +
    geom_smooth(aes(x=Hhmlbody_sum, y=Biotek_Hhml_body), method="lm", se=FALSE, colour = colorvec[2]) +
    geom_point(aes(x=hhhlbody_sum, y=Biotek_hhhl_body), colour = colorvec[3]) +
    geom_smooth(aes(x=hhhlbody_sum, y=Biotek_hhhl_body), method="lm", se=FALSE, colour = colorvec[3]) +
    theme_cowplot() +
    easy_labs(x = "OTU size (number of reads)", 
         y = "genomic DNA input (ng/µl)",
         subtitle = "body") +
    easy_move_legend(to = "none") +
    easy_x_axis_title_size(11) +
    easy_y_axis_title_size(11)

# p1 + p2

p3 <- ggplot(OTUBLASTqpcrA) +
    geom_point(aes(x=hlllleg_sum, y=qPCR_hlll_leg), colour = colorvec[1]) +
    geom_smooth(aes(x=hlllleg_sum, y=qPCR_hlll_leg), method="lm", se=FALSE, colour = colorvec[1]) +
    geom_point(aes(x=Hhmlleg_sum, y=qPCR_Hhml_leg), colour = colorvec[2]) +
    geom_smooth(aes(x=Hhmlleg_sum, y=qPCR_Hhml_leg), method="lm", se=FALSE, colour = colorvec[2]) +
    geom_point(aes(x=hhhlleg_sum, y=qPCR_hhhl_leg), colour = colorvec[3]) +
    geom_smooth(aes(x=hhhlleg_sum, y=qPCR_hhhl_leg), method="lm", se=FALSE, colour = colorvec[3]) +
    theme_cowplot() +
    easy_labs(x="OTU size (number of reads)", 
         y="COI amplicon concentration (ng/µl)",
         subtitle = "leg") +
    easy_move_legend(to = "none") +
    easy_x_axis_title_size(11) +
    easy_y_axis_title_size(11)

p4 <- ggplot(OTUBLASTqpcrA) +
    geom_point(aes(x=hlllleg_sum, y=Biotek_hlll_leg), colour = colorvec[1]) +
    geom_smooth(aes(x=hlllleg_sum, y=Biotek_hlll_leg), method="lm", se=FALSE, colour = colorvec[1]) +
    geom_point(aes(x=Hhmlleg_sum, y=Biotek_Hhml_leg), colour = colorvec[2]) +
    geom_smooth(aes(x=Hhmlleg_sum, y=Biotek_Hhml_leg), method="lm", se=FALSE, colour = colorvec[2]) +
    geom_point(aes(x=hhhlleg_sum, y=Biotek_hhhl_leg), colour = colorvec[3]) +
    geom_smooth(aes(x=hhhlleg_sum, y=Biotek_hhhl_leg), method="lm", se=FALSE, colour = colorvec[3]) +
    theme_cowplot() +
    easy_labs(x = "OTU size (number of reads)", 
         y = "genomic DNA input (ng/µl)",
         subtitle = "leg") +
    easy_move_legend(to = "none") +
    easy_x_axis_title_size(11) +
    easy_y_axis_title_size(11)

# p3 + p4

(p1 + p2) / (p3 + p4)
```

linear models
1. create long data subsets
2. compare ggplots to confirm that pivot_longer code worked correctly
3. run linear models
```{r}
qpcrbody <- OTUBLASTqpcrA %>% 
    select(contains("body")) %>% 
    select(!starts_with("Biotek")) %>% 
    rename(Hhmlbody_reads = Hhmlbody_sum, 
           hhhlbody_reads = hhhlbody_sum, 
           hlllbody_reads = hlllbody_sum, 
           hlllbody_qpcr = qPCR_hlll_body, 
           hhhlbody_qpcr = qPCR_hhhl_body, 
           Hhmlbody_qpcr = qPCR_Hhml_body
           ) %>% 
  pivot_longer(everything(),
               names_to = c("soup", ".value"),
               names_pattern = "(.+)_(.+)"
               )

qpcrleg <- OTUBLASTqpcrA %>% 
    select(contains("leg")) %>% 
    select(!starts_with("Biotek")) %>% 
    rename(Hhmlleg_reads = Hhmlleg_sum, 
           hhhlleg_reads = hhhlleg_sum, 
           hlllleg_reads = hlllleg_sum, 
           hlllleg_qpcr = qPCR_hlll_leg, 
           hhhlleg_qpcr = qPCR_hhhl_leg, 
           Hhmlleg_qpcr = qPCR_Hhml_leg
           ) %>% 
  pivot_longer(everything(),
               names_to = c("soup", ".value"),
               names_pattern = "(.+)_(.+)"
               )

gdnabody <- OTUBLASTqpcrA %>% 
    select(contains("body")) %>% 
    select(!starts_with("qPCR")) %>% 
    rename(Hhmlbody_reads = Hhmlbody_sum, 
           hhhlbody_reads = hhhlbody_sum, 
           hlllbody_reads = hlllbody_sum, 
           hlllbody_gdna = Biotek_hlll_body, 
           hhhlbody_gdna = Biotek_hhhl_body, 
           Hhmlbody_gdna = Biotek_Hhml_body
           ) %>% 
  pivot_longer(everything(),
               names_to = c("soup", ".value"),
               names_pattern = "(.+)_(.+)"
               )

gdnaleg <- OTUBLASTqpcrA %>% 
    select(contains("leg")) %>% 
    select(!starts_with("qPCR")) %>% 
    rename(Hhmlleg_reads = Hhmlleg_sum, 
           hhhlleg_reads = hhhlleg_sum, 
           hlllleg_reads = hlllleg_sum, 
           hlllleg_gdna = Biotek_hlll_leg, 
           hhhlleg_gdna = Biotek_hhhl_leg, 
           Hhmlleg_gdna = Biotek_Hhml_leg
           ) %>% 
  pivot_longer(everything(),
               names_to = c("soup", ".value"),
               names_pattern = "(.+)_(.+)"
               )

p5 <- ggplot(qpcrbody) +
    geom_point(aes(x=reads, y=qpcr, group=soup, color=soup)) +
    geom_smooth(aes(x=reads, y=qpcr, group=soup, color=soup), method="lm", se=FALSE) +
    theme_cowplot() +
    easy_labs(x = "OTU size (number of reads)", 
         y = "COI amplicon concentration (ng/µl)",
         subtitle = "body") +
    easy_move_legend(to = "none") +
    easy_x_axis_title_size(11) +
    easy_y_axis_title_size(11)

p1 + p5

p6 <- ggplot(qpcrleg) +
    geom_point(aes(x=reads, y=qpcr, group=soup, color=soup)) +
    geom_smooth(aes(x=reads, y=qpcr, group=soup, color=soup), method="lm", se=FALSE) +
    theme_cowplot() +
    easy_labs(x = "OTU size (number of reads)", 
         y = "COI amplicon concentration (ng/µl)",
         subtitle = "leg") +
    easy_move_legend(to = "none") +
    easy_x_axis_title_size(11) +
    easy_y_axis_title_size(11)

p3 + p6

p7 <- ggplot(gdnabody) +
    geom_point(aes(x=reads, y=gdna, group=soup, color=soup)) +
    geom_smooth(aes(x=reads, y=gdna, group=soup, color=soup), method="lm", se=FALSE) +
    theme_cowplot() +
    easy_labs(x = "OTU size (number of reads)", 
         y = "genomic DNA input (ng/µl)",
         subtitle = "body") +
    easy_move_legend(to = "none") +
    easy_x_axis_title_size(11) +
    easy_y_axis_title_size(11)

p2 + p7

p8 <- ggplot(gdnaleg) +
    geom_point(aes(x=reads, y=gdna, group=soup, color=soup)) +
    geom_smooth(aes(x=reads, y=gdna, group=soup, color=soup), method="lm", se=FALSE) +
    theme_cowplot() +
    easy_labs(x = "OTU size (number of reads)", 
         y = "genomic DNA input (ng/µl)",
         subtitle = "leg") +
    easy_move_legend(to = "none") +
    easy_x_axis_title_size(11) +
    easy_y_axis_title_size(11)

p4 + p8

modqpcrbody1 <- lm(qpcr ~ reads + soup + reads:soup, data = qpcrbody)
modqpcrbody2 <- lm(qpcr ~ reads + soup, data = qpcrbody)
anova(modqpcrbody1, modqpcrbody2)
summary(modqpcrbody1)
par(mfrow=c(2,2))
plot(modqpcrbody1)
par(mfrow=c(1,1))
# performance::check_model(modqpcrbody1)

modqpcrleg1 <- lm(qpcr ~ reads + soup + reads:soup, data = qpcrleg)
modqpcrleg2 <- lm(qpcr ~ reads + soup, data = qpcrleg)
anova(modqpcrleg1, modqpcrleg2)
summary(modqpcrleg1)
par(mfrow=c(2,2))
plot(modqpcrleg1)
par(mfrow=c(1,1))

modgdnaleg1 <- lm(gdna ~ reads + soup + reads:soup, data = gdnaleg)
modgdnaleg2 <- lm(gdna ~ reads + soup, data = gdnaleg)
anova(modgdnaleg1, modgdnaleg2)
summary(modgdnaleg1)
par(mfrow=c(2,2))
plot(modgdnaleg1)
par(mfrow=c(1,1))

modgdnabody1 <- lm(gdna ~ reads + soup + reads:soup, data = gdnabody)
modgdnabody2 <- lm(gdna ~ reads + soup, data = gdnabody)
anova(modgdnabody1, modgdnabody2)
summary(modgdnabody1)
par(mfrow=c(2,2))
plot(modgdnabody1)
par(mfrow=c(1,1))
```


########################################################################
Taxonomic amplification bias, Figure 4
########################################################################
Using Begumfilter stringency level "Filter_min2PCRs_min4copies" and mmmm_body
```{r metacoder}
# create tibble of the PCRs to compare (A, C, E, F, G) (omitting PCR replicates)
soup_mmmm <- tribble(
  ~Soups,   ~PCR_condition,   ~Description,   ~DNA_Source,
"A",   "oTa_oC",   "A_optTa_optCyc",   "mmmmbody",
"E",   "oTa_lC",   "E_optTa_loCyc",   "mmmmbody",
"C",   "hTa_oC",   "C_highTa_optCyc",   "mmmmbody",
"F",   "oTa_hC",   "F_optTa_hiCyc",   "mmmmbody",
"G",   "TD",   "G_Touchdown",   "mmmmbody"
)

# read in taxonomies assigned to ref sequences by GBIF website: https://www.gbif.org/tools/sequence-id
gbiftaxMTB <- read_csv(file.path("..", "data", "MTB", "blastresult_20200330.csv")) %>% 
    select(occurrenceId, matchType, classification) %>% 
    separate(classification, into = c("kingdom", "phylum", "class", "order", "family", "genus", "species"), sep = "_", remove = FALSE)

# reformat OTUBLAST list
OTUBLASTtax <- OTUBLAST[c("A","C","E","F","G")] # keep only A,C,E,F,G
OTUBLASTselect <- function(x){
    x %>% select(mmmmbody, sseqid)
}
OTUBLASTtax <- map_dfr(OTUBLASTtax, OTUBLASTselect, .id = "PCR")
OTUBLASTtax_summ <- OTUBLASTtax %>% 
    filter(!is.na(sseqid)) %>% 
    group_by(PCR, sseqid) %>% 
    summarise(
        mmmmbody = sum(mmmmbody)
    )
OTUBLASTtax_wide <- OTUBLASTtax_summ %>% 
    pivot_wider(names_from = "PCR", values_from = "mmmmbody", values_fill = list(mmmmbody = 0))

otu_mmmm <- OTUBLASTtax_wide %>% 
    left_join(gbiftaxMTB, by = c("sseqid" = "occurrenceId")) %>% 
    select(-matchType, -species) %>% 
    rowwise() %>% 
    mutate(
        sumreads = sum(A,C,E,F,G)
    ) %>% 
    filter(sumreads > 0) %>% 
    select(-sumreads)

# metacoder heat tree
# parse the taxonomic information using a parser from {taxa}
obj <- parse_tax_data(otu_mmmm, 
       class_cols = c("kingdom", "phylum", "class", "order", "family", "genus"), class_sep = "_", named_by_rank = TRUE)

# obj <- parse_tax_data(otu_mmmm, class_cols = "classification", class_sep = "_")
print(obj)
# This returns a taxmap object. The taxmap class is designed to store any number of tables, lists, or vectors associated with taxonomic information and facilitate manipulating the data in a cohesive way. 

# accounting for uneven sampling
obj$data$tax_data <- calc_obs_props(obj, "tax_data")
print(obj)

# Getting per-taxon information
# Currently, we have values for the abundance of each OTU, not each taxon. To get information on the taxa, we can sum the abundance per-taxon like so:
obj$data$tax_abund <- calc_taxon_abund(obj, "tax_data")
print(obj)

# Note that there is now an additional table with one row per taxon.
# We can also easily calculate the number of samples have reads for each taxon:
obj$data$tax_occ <- calc_n_samples(obj, "tax_abund", groups = soup_mmmm$PCR_condition)
print(obj)

# Plotting taxonomic data
# Now that we have per-taxon information, we can plot the information using heat trees. The code below plots the number of samples that have reads for each taxon. It also plots the number of OTUs assigned to each taxon in the overall dataset.
heat_tree(obj, node_label = obj$taxon_names(),
          node_size = obj$n_obs(),
          node_color = obj$data$tax_occ$oTa_oC, 
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads")


# Compare PCR conditions
obj$data$diff_table <- compare_groups(obj, dataset = "tax_abund",
                                      cols = soup_mmmm$Soups,
                                      groups = soup_mmmm$Description) # PCR_condition
print(obj$data$diff_table)
heat_tree_matrix(obj,
                 data = "diff_table",
                 node_size = n_obs,
                 node_label = taxon_names,
                 node_color = log2_median_ratio,
                 node_color_range = diverging_palette(),
                 node_color_trans = "linear",
                 node_color_interval = c(-3, 3),
                 edge_color_interval = c(-3, 3),
                 node_size_axis_label = "Number of OTUs",
                 node_color_axis_label = "Log2 ratio median proportions")
```

Read counts
```{r}
readcount <- read_table2(file.path("..", "data", "seqs",
                                "mergedtrimmed_read_counts.txt")
                         )

readcountAF <- readcount %>% slice(1:18)
readcountGH <- readcount %>% slice(19:24)

sum(readcountAF$num_seqs) # 7139290
mean(readcountAF$num_seqs) # 396627.2

sum(readcountGH$num_seqs) # 6356655
mean(readcountGH$num_seqs) # 1059442
```


<details>
<summary>Reproducibility receipt</summary>
```{r}
# datetime
Sys.time()

# repository
git2r::repository(here::here())

envDocument::env_doc("table", git = FALSE)
```
